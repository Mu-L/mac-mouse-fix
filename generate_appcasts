#!/usr/bin/python3

# Imports

import sys
import os
import shutil
# import requests # Only ships with python2 on mac it seems. Edit: So what? We could just install it right?
import urllib.request
import urllib.parse

from pathlib import Path

import json

import textwrap
from pprint import pprint

import subprocess

# Test mode
TEST_MODE = False
if len(sys.argv) >= 2 and sys.argv[1] == '--test-mode':
    print('Running in --test-mode')
    TEST_MODE = True

# Constants
#   Paths are relative to project root or to each other.

# URLs
releases_api_url        = "https://api.github.com/repos/noah-nuebling/mac-mouse-fix/releases"

if TEST_MODE:
    base_url            = "http://127.0.0.1:8000"       # For testing. Run `python3 -m http.server 8000` to serve this repo at that url. Background: `file://` and `localhost:` URLs are forbidden by Sparkle, this is a workaround. Read more in README.md. Stand [Feb 2025]
else:
    base_url            = "https://raw.githubusercontent.com/noah-nuebling/mac-mouse-fix/update-feed"

if False:
    proxy_url               = "https://noah-nuebling.github.io/mmf-update-notes-proxy/?url="
    raw_github_url      = "https://raw.githubusercontent.com/noah-nuebling/mac-mouse-fix/master"

# Output paths/folders
appcast_file_name               = "appcast.xml"                             # Path to the appcast for stable releases
appcast_pre_file_name           = "appcast-pre.xml"                         # Path to the appcast for prereleases

appcast_url                     = f"{base_url}/{appcast_file_name}"         # This gets included as a link in appcast.xml. Not sure what it does.
appcast_pre_url                 = f"{base_url}/{appcast_pre_file_name}"

update_notes_folder            = "update-notes/html"                        # This is where the html update notes go. They are generated from the .md update notes downloaded off GitHub. appcast.xml will reference these html update notes via <sparkle:releaseNotesLink>
css_file_path                  = "update-notes/style.css"                   # The css file referenced by the html update notes.
js_file_path                   = "update-notes/script.js"

# Implementation detail paths/folders

sparkle_project_path            = "Frameworks/Sparkle-1.27.3"                       # Need this to use Sparkles code-signing tool # This is dangerously hardcoded # Might be smart to keep this in sync with the Sparkle version in the app.
download_folder                 = "generate_appcasts_downloads"                     # This is were we download old app versions to, and then unzip them. We want to delete this on exit.
app_bundle_name                 = "Mac Mouse Fix.app"                               # This is the name of the app bundle after unzipping it
html_header_includes_tmp_file   = f"{download_folder}/html_header_includes.html"    # Temp file for storing html headers for update notes. I guess we're using downloads_folder as a general 'tmp' folder here.

info_plist_app_subpath          = "Contents/Info.plist"         # Where to look fo the Info.plist file within the unzipped app bundle

prefpane_bundle_name = "Mouse Fix.prefpane"                     # App has been renamed, this is the old name

# Dynamic paths/folders
current_directory = os.getcwd()
download_folder_absolute = os.path.join(current_directory, download_folder)

# Stuff for reading directly from the project source files. 
#   We went over to downloading and unzipping all old bundles instead.
#   Note: 
#       Accessing Xcode environment variables is night impossible it seems
#       The only way to do it I found is described here:
#         https://stackoverflow.com/questions/6523655/how-do-you-access-xcode-environment-and-build-variables-from-an-external-script
#         And that's not feasible to do for old versions.

if False:
    info_plist_path = "App/SupportFiles/Info.plist"
    base_xcconfig_path = "xcconfig/Base.xcconfig"
    files_to_checkout = [info_plist_path, base_xcconfig_path]

def generate():
    try:

        # Check if there are uncommited changes
        #   Note: This script uses git stash several times, so they'd be lost Update: [Feb 2025] We don't seem to be using git stash anymore. We can probably turn this off. (./update still checks for uncommited changes, so that should be safe.)
        if TEST_MODE or True:
            pass
        else: 
            uncommitted_changes = subprocess.check_output('git diff-index HEAD --', shell=True).decode('utf-8')
            if (len(uncommitted_changes) != 0):
                raise Exception('There are uncommited changes. Please commit or stash them before running this script.')

        # Main logic
        
        # Call GH API
        with urllib.request.urlopen(releases_api_url) as request:
            releases = json.load(request)

        # Make downloads folder
        os.makedirs(download_folder_absolute, exist_ok=True)

        # Prepare text to include in the html header of all release notes.
        #   (We have to write this to a file because I don't know how else to pass this to pandoc.)
        
        if True: 
            # Approach 1: Reference the css/js files
            #   This only works through githack, because raw.githubusercontent serves the css and js file with text/plain mime type.
            #   Meta: Is there any benefit over including the css/js files directly? The client will have to download the css/js either way to correctly display the update notes.
            html_header_includes = textwrap.dedent("""\
            <link rel="stylesheet" href="{css_slot}"/>
            <script src="{js_slot}"></script>\
            """).format(
                css_slot = apply_githack(f'{base_url}/{css_file_path}'),
                js_slot = apply_githack(f'{base_url}/{js_file_path}')
            )
        else: 
            # Approach 2: include the css/js files directly
            html_header_includes = textwrap.dedent("""\
            <style> 
            {css_slot} 
            </style>
            <script> 
            {js_slot} 
            </script>\
            """).format(css_slot = textwrap.indent(Path(css_file_path).read_text(), 4 * ' '), 
                        js_slot = textwrap.indent(Path(js_file_path).read_text(), 4 * ' '))
        
        with open(html_header_includes_tmp_file, 'w') as f:
            f.write(html_header_includes)

        # We'll be iterating over all releases and collecting data to put into the appcast
        appcast_items = []
        appcast_pre_items = [] # Items for the pre-release channel

        for r in releases:

            # Get short version
            short_version = r['name']
        
            # Log
            print(f'Processing release {short_version}...')

            # Get tag name
            tag_name = r['tag_name']

            # Get release notes
            release_notes = r['body'] # This is markdown

            # Write release notes to file. 
            #   Note: As a plain string I had trouble passing it to pandoc, because I couldn't escape it properly
            with open(f"{download_folder}/release_notes.md", "w") as f:
                f.write(release_notes)
            
            # Convert release notes to HTML 
            release_notes = subprocess.check_output(f"cat {download_folder}/release_notes.md | "
                                                    "pandoc "
                                                    "--from markdown --to html "
                                                    "--standalone "                 # Not sure what this does / if it's necessary
                                                    f"--include-in-header ./{html_header_includes_tmp_file} "
                                                    "--metadata title='' "
                                                    "--metadata document-css=false" # Stops pandoc from adding some of its default inline css, but can't manage to turn that off entirely.
                                                    ,
                                                    shell=True).decode('utf-8')

            # Write release notes
            release_notes_path = f"{update_notes_folder}/en/{tag_name}.html"
            os.makedirs(f"{update_notes_folder}/en/", exist_ok=True)
            with open(release_notes_path, 'w') as f:
                f.write(release_notes)

            # Get title
            title = f"{short_version} available!"

            # Get publishing date
            publishing_date = r['published_at'];

            # Get isPrerelease
            is_prerelease = r['prerelease']

            # Get type
            type = "application/octet-stream" # Not sure what this is or if this is right

            # Get localized release notes ?
            #   ...

            if False:

                # Tried to checkout each commit and then read bundle version and minimum compatible macOS version from the local Xcode source files. 
                # I had trouble making this approach work, though, so we went over to just unzipping each update and reading that data directly from the bundle

                # Get commit number
                # commit = os_system_exc(f"git rev-list -n 1 {tag_name}") # Can't capture the output of this for some reason
                commit_number = subprocess.check_output(f"git rev-list -n 1 {tag_name}", shell=True).decode('utf-8')
                commit_number = commit_number[0:-1] # There's a linebreak at the end

                # Check out commit
                # This would probably be a lot faster if we only checked out the files we need
                os_system_exc("git stash")
                files_string = ' '.join(files_to_checkout)
                bash_string = f"git checkout {commit_number} {files_string}"
                try:
                    subprocess.check_output(bash_string)
                except Exception as e:
                    print(f"Exception while checking out commit {commit_number} ({short_version}): {e}. Skipping this release.")
                    continue

                # Get version
                #   Get from Info.plist file
                bundle_version = subprocess.check_output(f"/usr/libexec/PlistBuddy {info_plist_path} -c 'Print CFBundleVersion'", shell=True).decode('utf-8')

                # Get minimum macOS version
                #   The environment variable buried deep within project.pbxproj. No practical way to get at this
                #   Instead, we're going to hardcode this for old versions and define a new env variable via xcconfig we can reference here for newer verisons
                #   See how alt-tab-macos did it here: https://github.com/lwouis/alt-tab-macos/blob/master/config/base.xcconfig
                minimum_macos_version = ""
                try:
                    minimum_macos_version = subprocess.check_output(f"awk -F ' = ' '/MACOSX_DEPLOYMENT_TARGET/ {{ print $2; }}' < {base_xcconfig_path}", shell=True).decode('utf-8')
                    minimum_macos_version = minimum_macos_version[0:-1] # Remove trailing \n character
                except:
                    minimum_macos_version = 10.11

            # Get app asset
            # NOTE: This has a copy in stats_internal.py. Keep them in sync.
            app_assets = [asset for asset in r['assets'] if asset['name'] == 'MacMouseFixApp.zip' or asset['name'] == 'MacMouseFix.zip'] # I don't think we need `MacMouseFix.zip` here (That's the old prefpane name.)
            assert len(app_assets) <= 1, f"Found {len(app_assets)} app assets. Here are the asset names: { list(map(lambda a: a['name'], r['assets'])) }"
            if len(app_assets) == 0:
                print(f"Couldn't find asset with standard name. Falling back to first asset, named {r['assets'][0]['name']}")
                app_assets = [r['assets'][0]]
            
            # Get download link
            download_link = app_assets[0]['browser_download_url']

            # Download update
            download_name = download_link.rsplit('/', 1)[-1]
            download_zip_path = f'{download_folder}/{download_name}'
            urllib.request.urlretrieve(download_link, download_zip_path)

            # Get edSignature
            signature_and_length = subprocess.check_output(f"./{sparkle_project_path}/bin/sign_update {download_zip_path}", shell=True).decode('utf-8')
            signature_and_length = signature_and_length[0:-1]

            # Unzip update
            os_system_exc(f'ditto -x -k --sequesterRsrc --rsrc "{download_zip_path}" "{download_folder}"') # This works, while subprocess.check_output() doesn't for some reason

            # Find app bundle
            #   Maybe we could just name the unzipped folder instead of guessing here
            #   Well we also use this to determine if the download is a prefpane or an app. There might be better ways to infer this but this should work
            is_prefpane = False
            app_path = f'{download_folder}/{app_bundle_name}'
            if not os.path.exists(app_path):
                app_path = f'{download_folder}/{prefpane_bundle_name}'
                if not os.path.exists(app_path):
                    raise Exception('Unknown bundle name after unzipping')
                else:
                    is_prefpane = True

            if is_prefpane:
                continue

            # Find Info.plist in app bundle
            info_plist_path = f'{app_path}/{info_plist_app_subpath}'

            # Read stuff from Info.plist
            bundle_version = subprocess.check_output(f"/usr/libexec/PlistBuddy '{info_plist_path}' -c 'Print CFBundleVersion'", shell=True).decode('utf-8')
            minimum_macos_version = subprocess.check_output(f"/usr/libexec/PlistBuddy '{info_plist_path}' -c 'Print LSMinimumSystemVersion'", shell=True).decode('utf-8')
            bundle_version = bundle_version[0:-1]
            minimum_macos_version = minimum_macos_version[0:-1]

            # Delete bundle we just processed so that we won't accidentally process it again next round (that happens if the next bundle has prefpane_bundle_name instead of app_bundle_name)
            shutil.rmtree(app_path)

            # Assemble collected data into appcast.xml-ready item-string
            #  
            #   About release notes & appcast.xml format:
            #       Release notes can be embedded directly in the appcast.xml using <description> or via a link using <sparkle:releaseNotesLink>
            #           Originally, we used <description> to keep things simple, but this caused the appcast.xml to contain countless copies of our custom css and js text.
            #           I couldn't figure out how to fix that without switching to <sparkle:releaseNotesLink>, so we did switch in [Feb 2025]
            #       
            #   <sparkle:releaseNotesLink> complications:
            #   - [Feb 2025] We're prepending base_url, because I don't think the <sparkle:releaseNotesLink> can be a relative URL. 
            #   - [Feb 2025] <sparkle:releaseNotesLink> requires githack since raw.githubusercontent serves the html file with text/plain mime type, which makes Sparkle update window in MMF display the html source code as plain text.
            #       - Before githack, we used a custom proxy to change mime-types, but it worked clientside and so required js which wasn't activated in the update window of older MMF versions.
            #       - See: https://github.com/noah-nuebling/mmf-update-notes-proxy

            #   References: 
            #       - [SUAppcastItem releaseNotesURL] docs (https://sparkle-project.org/documentation/api-reference/Classes/SUAppcastItem.html#/c:objc(cs)SUAppcastItem(py)releaseNotesURL)
            #           - Explains difference between <sparkle:releaseNotesLink> and <description>
            #       - SampleAppcast.xml 1 (https://github.com/sparkle-project/Sparkle/blob/2.x/Resources/SampleAppcast.xml)
            #           - Contained in main Sparkle repo, uses <sparkle:releaseNotesLink>
            #       - SampleAppcast.xml 2 (https://sparkle-project.org/files/sparkletestcast.xml)
            #           - Linked from Sparkle docs, uses <description>

            if True:
                # Approach 1: <sparkle:releaseNotesLink>
                #   (Requires githack to fix mime type)
                release_notes_str = "<sparkle:releaseNotesLink>{release_notes_link_slot}</sparkle:releaseNotesLink>".format(
                    release_notes_link_slot = apply_githack(f"{base_url}/{release_notes_path}")
                )
            else:
                # Approach 2: <description>
                #   (This bloats the appcast file quite a lot)
                release_notes_str = textwrap.dedent("""\
                <description>
                {release_notes_slot}
                </description>\
                """).format(release_notes_slot = release_notes)

            item_string = textwrap.dedent("""\
            <item>
                <title>{title_slot}</title>
                <pubDate>{publishing_date_slot}</pubDate>
                <sparkle:minimumSystemVersion>{minimum_macos_version_slot}</sparkle:minimumSystemVersion>
                {release_notes_str_slot}
                <enclosure
                    url=\"{download_link_slot}\"
                    sparkle:version=\"{bundle_version_slot}\"
                    sparkle:shortVersionString=\"{short_version_slot}\"
                    {signature_and_length_slot}
                    type=\"{type_slot}\"
                />
            </item>\
            """).format(
                title_slot                  = title,
                publishing_date_slot        = publishing_date,
                minimum_macos_version_slot  = minimum_macos_version,
                release_notes_str_slot      = release_notes_str,
                download_link_slot          = download_link,
                bundle_version_slot         = bundle_version,
                short_version_slot          = short_version,
                signature_and_length_slot   = signature_and_length,
                type_slot                   = type
            )

            # Append item_string to arrays
            if not is_prerelease:
                appcast_items.append(item_string)

            appcast_pre_items.append(item_string)

        # Assemble item strings into final appcast strings
        appcast_content_string = textwrap.dedent('''\
        <?xml version="1.0" encoding="utf-8"?>
        <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle"  xmlns:dc="http://purl.org/dc/elements/1.1/">
        <channel>
            <title>Mac Mouse Fix Update Feed</title>
            <link>{}</link>
            <description>Stable releases of Mac Mouse Fix</description>
            <language>en</language>
            {}
        </channel>
        </rss>\
        ''').format(appcast_url, '\n'.join(appcast_items))

        appcast_pre_content_string = textwrap.dedent('''\
        <?xml version="1.0" encoding="utf-8"?>
        <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle"  xmlns:dc="http://purl.org/dc/elements/1.1/">
          <channel>
            <title>Mac Mouse Fix Update Feed for Prereleases</title>
            <link>{}</link>
            <description>Prereleases of Mac Mouse Fix</description>
            <language>en</language>
            {}
          </channel>
        </rss>\
        ''').format(appcast_pre_url, '\n'.join(appcast_pre_items))

        # Write to file
        with open(appcast_file_name, "w") as f:
            f.write(appcast_content_string)
        with open(appcast_pre_file_name, "w") as f:
            f.write(appcast_pre_content_string)

        # Cleanup & exit
        clean_up(download_folder)
        exit(0)

    except Exception as e: # Exit immediately if anything goes wrong
        print(e)
        clean_up(download_folder)
        exit(1)

def clean_up(download_folder):
    ret = os.system(f'rm -R {download_folder}')
    if ret != 0:
        print(f'Clean up failed with error code: {ret}')

def apply_githack(url: str):
    # Note: raw.githack.com says to use rawcdn.githack.com in production but that requires us to know the git commit, which would complicate the logic.
    if TEST_MODE:
        return url  # In TEST_MODE we host the files locally and they'll be served with the right mime type
    else:
        return url.replace('raw.githubusercontent.com', 'raw.githack.com')

def os_system_exc(s): 
    ret = os.system(s)
    if ret != 0:
        raise Exception(f"os.system failed with error code {ret}")

generate()